From 9cc11aa9c14bfc65d43f975c44d83adf7926138c Mon Sep 17 00:00:00 2001
From: Tejas Patel <tejas.patel1@einfochips.com>
Date: Tue, 19 Oct 2021 14:40:50 +0530
Subject: [PATCH 10/16] IMX8 THOR96: Enabled DSI to HDMI (ADV7533 bridge chip)

Change-Id: Ibb2e1659dd07ceae8f30f1094044eb2d3108c264
Signed-off-by: Tejas Patel <tejas.patel1@einfochips.com>
Signed-off-by: Tanvi Chauhan <tanvi.chauhan@einfochips.com>

diff --git a/arch/arm64/boot/dts/freescale/imx8mq-thor96.dts b/arch/arm64/boot/dts/freescale/imx8mq-thor96.dts
index 19760cf3a..b0768908a 100644
--- a/arch/arm64/boot/dts/freescale/imx8mq-thor96.dts
+++ b/arch/arm64/boot/dts/freescale/imx8mq-thor96.dts
@@ -106,7 +106,7 @@
 		model = "imx-spdif";
 		spdif-controller = <&spdif1>;
 		spdif-out;
-		spdif-in;
+		status = "okay";
 	};
 
         sound-adau1361 {
@@ -121,6 +121,7 @@
 		model = "imx-hdmi-arc";
 		spdif-controller = <&spdif2>;
 		spdif-in;
+		status = "okay";
 	};
 
 	reg_usdhc1_vmmc: reg-usdhc1-vmmc {
@@ -341,10 +342,17 @@
 			};
 		};
 	};
+
+        adv_bridge: adv7535@3d {
+                compatible = "adi,adv7533";
+                reg = <0x3d>;
+                adi,addr-cec = <0x3b>;
+                adi,dsi-lanes = <4>;
+                status = "okay";
+        };
 };
 
 &sai1 {
-
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_sai1>;
 	assigned-clocks = <&clk IMX8MQ_CLK_SAI1>,
@@ -478,17 +486,6 @@
 		synaptics,diagonal-rotation;
 		status = "disabled";
 	};
-
-	adv_bridge: adv7535@3d {
-		compatible = "adi,adv7535";
-		reg = <0x3d>;
-		adi,addr-cec = <0x3b>;
-		adi,dsi-lanes = <4>;
-		pinctrl-0 = <&pinctrl_i2c1_dsi_ts_int>;
-		interrupt-parent = <&gpio5>;
-		interrupts = <7 IRQ_TYPE_LEVEL_LOW>;
-		status = "disabled";
-	};
 };
 
 /* HS-I2C3 */
@@ -873,7 +870,7 @@
 	pinctrl_spdif1: spdif1grp {
 		fsl,pins = <
 			MX8MQ_IOMUXC_SPDIF_TX_SPDIF1_OUT	0xd6
-			MX8MQ_IOMUXC_SPDIF_RX_SPDIF1_IN		0xd6
+			MX8MQ_IOMUXC_SPDIF_RX_SPDIF1_IN		0xd6 /*USED IN ZIGBEE*/
 		>;
 	};
 
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
index b550f53a0..301aa4566 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
@@ -42,15 +42,15 @@ static const struct reg_sequence adv7511_fixed_registers[] = {
  */
 
 static const uint8_t adv7511_register_defaults[] = {
-	0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 00 */
-	0x00, 0x00, 0x01, 0x0e, 0xbc, 0x18, 0x01, 0x13,
+	0x12, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, /* 00 */
+	0x00, 0x00, 0x51, 0x8e, 0xb8, 0x18, 0x01, 0x13,
 	0x25, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 10 */
 	0x46, 0x62, 0x04, 0xa8, 0x00, 0x00, 0x1c, 0x84,
 	0x1c, 0xbf, 0x04, 0xa8, 0x1e, 0x70, 0x02, 0x1e, /* 20 */
 	0x00, 0x00, 0x04, 0xa8, 0x08, 0x12, 0x1b, 0xac,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 30 */
 	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xb0,
-	0x00, 0x50, 0x90, 0x7e, 0x79, 0x70, 0x00, 0x00, /* 40 */
+	0x00, 0x50, 0x90, 0x7e, 0xff, 0x70, 0x00, 0x00, /* 40 */
 	0x00, 0xa8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x02, 0x0d, 0x00, 0x00, 0x00, 0x00, /* 50 */
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -68,7 +68,7 @@ static const uint8_t adv7511_register_defaults[] = {
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* c0 */
 	0x00, 0x03, 0x00, 0x00, 0x02, 0x00, 0x01, 0x04,
-	0x30, 0xff, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, /* d0 */
+	0x30, 0xff, 0x80, 0x80, 0x80, 0x00, 0x48, 0x00, /* d0 */
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01,
 	0x80, 0x75, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, /* e0 */
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -709,6 +709,16 @@ adv7511_detect(struct adv7511 *adv7511, struct drm_connector *connector)
 				   ADV7511_REG_POWER2_HPD_SRC_BOTH);
 	}
 
+        regmap_write(adv7511->regmap, 0xD6, 0x48);
+        regmap_write(adv7511->regmap, 0x01,0x00);
+        regmap_write(adv7511->regmap, 0x02,0x18);
+        regmap_write(adv7511->regmap, 0x03,0x00);
+        regmap_write(adv7511->regmap, 0x0A,0x51);
+        regmap_write(adv7511->regmap, 0x0B,0x8E);
+        regmap_write(adv7511->regmap, 0x0C,0xB8);
+        regmap_write(adv7511->regmap, 0x44,0xFF);
+        regmap_write(adv7511->regmap_cec, 0x05,0xc8);
+
 	adv7511->status = status;
 	return status;
 }
@@ -1390,6 +1400,16 @@ static int adv7511_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
 	drm_bridge_add(&adv7511->bridge);
 
 	adv7511_audio_init(dev, adv7511);
+
+        regmap_write(adv7511->regmap, 0x01,0x00);
+        regmap_write(adv7511->regmap, 0x02,0x18);
+        regmap_write(adv7511->regmap, 0x03,0x00);
+        regmap_write(adv7511->regmap, 0x0A,0x51);
+        regmap_write(adv7511->regmap, 0x0B,0x8E);
+        regmap_write(adv7511->regmap, 0x0C,0xB8);
+        regmap_write(adv7511->regmap, 0x44,0xFF);
+        regmap_write(adv7511->regmap_cec, 0x05,0xc8);
+
 	return 0;
 
 err_unregister_cec:
-- 
2.17.1

