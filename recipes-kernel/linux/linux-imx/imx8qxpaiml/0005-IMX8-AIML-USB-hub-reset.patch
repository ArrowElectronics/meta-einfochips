From e534be5494f50a33915032878d2f66e7a40d9cb7 Mon Sep 17 00:00:00 2001
From: "darshak.patel" <darshak.patel@einfochips.com>
Date: Tue, 20 Oct 2020 17:32:49 +0530
Subject: [PATCH] IMX8 AIML: USB hub reset

---
 .../boot/dts/freescale/imx8x-aiml-ei.dtsi     |  7 ++-
 drivers/usb/cdns3/core.c                      | 45 +++++++++++++++++++
 2 files changed, 51 insertions(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/freescale/imx8x-aiml-ei.dtsi b/arch/arm64/boot/dts/freescale/imx8x-aiml-ei.dtsi
index da97bc86c9fe..372f4672d98f 100644
--- a/arch/arm64/boot/dts/freescale/imx8x-aiml-ei.dtsi
+++ b/arch/arm64/boot/dts/freescale/imx8x-aiml-ei.dtsi
@@ -579,7 +579,7 @@
 };

 &usbotg3 {
-	dr_mode = "otg";
+	dr_mode = "host";
	status = "okay";
 };

@@ -981,4 +981,9 @@
		>;
	};

+	pinctrl_usb_hub_reset: usb_hub_reset { /* USB HUB */
+		fsl,pins = <
+			IMX8QXP_USB_SS3_TC1_LSIO_GPIO4_IO04                0x21
+		>;
+        };
 };
diff --git a/drivers/usb/cdns3/core.c b/drivers/usb/cdns3/core.c
index 2065c2cb1b1d..84bc6aa814e2 100644
--- a/drivers/usb/cdns3/core.c
+++ b/drivers/usb/cdns3/core.c
@@ -35,6 +35,10 @@
 #include "core.h"
 #include "host-export.h"
 #include "gadget-export.h"
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
+#define IMX8ML_USB_HUB_RESET_GPIO 132

 /**
  * cdns3_handshake - spin reading  until handshake completes or fails
@@ -600,6 +604,39 @@ static const struct attribute_group cdns3_attr_group = {
	.attrs = cdns3_attrs,
 };

+/**
+ * msm_usb_hub_reset: resets usb hub at gpio4_4
+ */
+static int msm_usb_hub_reset(void)
+{
+		int ret;
+		ret = gpio_request(IMX8ML_USB_HUB_RESET_GPIO, "usb_hub_reset_gpio");
+		if (ret) {
+				printk("gpio request failed ret=%d", ret);
+				return ret;
+		}
+
+		ret = gpio_direction_output(IMX8ML_USB_HUB_RESET_GPIO, 0);
+		if (ret) {
+				printk("can't set direction of reset gpio ret=%d", ret);
+				return ret;
+		}
+
+		printk("GPIO_Value is currently:  %d\n", gpio_get_value(IMX8ML_USB_HUB_RESET_GPIO));
+
+		gpio_export(IMX8ML_USB_HUB_RESET_GPIO, false);
+
+		usleep_range(15, 1000);
+
+		ret = gpio_direction_output(IMX8ML_USB_HUB_RESET_GPIO, 1);
+		if (ret) {
+				printk("can't set direction of reset gpio ret=%d", ret);
+				return ret;
+		}
+		printk("GPIO_Value is currently after delay of: %d\n", gpio_get_value(IMX8ML_USB_HUB_RESET_GPIO));
+		return 0;
+}
+
 /**
  * cdns3_probe - probe for cdns3 core device
  * @pdev: Pointer to cdns3 core platform device
@@ -726,6 +763,14 @@ static int cdns3_probe(struct platform_device *pdev)
	 * and we also needs a small delay to avoid frequently entering low
	 * power mode.
	 */
+	ret = msm_usb_hub_reset();
+
+	if (ret) {
+			printk("USB hub reset failed with ret=%d", ret);
+	}
+
+	printk("USB hub reset done");
+
	pm_runtime_set_autosuspend_delay(dev, 20);
	pm_runtime_mark_last_busy(dev);
	pm_runtime_use_autosuspend(dev);
--
2.17.1
